---
title: "Journal"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: false
    toc_depth: 1
    #code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, cache=TRUE)
```
Last compiled: `r Sys.Date()`

##### I'm an R enthusiast. Below are some resources and codes I've been recently exploring. I hope you'll join me on this journey!

# R resources
1. This is the definitive guide for all things R Markdown 
https://bookdown.org/yihui/rmarkdown/

2. Yihui Xie's bookdown package is used to write books and other long-form articles with R Markdown.
https://bookdown.org/yihui/bookdown/

I'll first load some packages so I can use all the functions later
```{r results='hide', message=FALSE, warning=FALSE}
library(here)
library(multilevel)
library(lme4)
library(tidyverse)
library(metafor)
library(readxl)
library(tidyverse)
library(MASS)
library(ggplot2)
library(SimMultiCorrData)
library(rlist)
library(haven)
library(writexl)
library(rstatix)
library(purrr) 
library(broom) 
library(faux)
library(multcomp)
library(jtools) # for summ()
library(mvtnorm) # References rmvnorm()
library(ellipse) # References ellipse()
```

## Interactive plots for response surface with a cutting plane
1. Create surface and cutting plane 
```{r}
compose1 <- function(f, c) {
  g <- function(y) f(c, y)
  return(g)
}

compose2 <- function(f, c) {
  g <- function(x) f(x, c)
  return(g)
}

composefh <- function(f, h) {
  g <- function(x) f(x, h(x))
  return(g)
}

get_curve <- function(M, v, f) {
  x0 <- M[1]
  y0 <- M[2]
  a <- v[1]
  b <- v[2]
  
  if (a == 0 & b != 0) {
    g <- compose1(f, x0)
    id <- 1
  } else if (a != 0 & b == 0) {
    g <- compose2(f, y0)
    id <- 2
  } else {
    h <- function(x) y0 + b * (x - x0) / a
    g <- composefh(f, h(x))
    id <- 3
  }
  return(list(g = g, id = id))
}


get_plane <- function(M, v, id, xx, yy, zz) {
  x0 <- M[1]
  y0 <- M[2]
  a <- v[1]
  b <- v[2]

  if (id == 1) {
    YZ <- expand.grid(yy, zz)
    X <- matrix(rep(x0, nrow(YZ)), nrow = nrow(YZ), ncol = ncol(YZ))
    Y <- matrix(YZ[,1], nrow = nrow(YZ), ncol = ncol(YZ))
    Z <- matrix(YZ[,2], nrow = nrow(YZ), ncol = ncol(YZ))
  } else if (id == 2) {
    XZ <- expand.grid(xx, zz)
    X <- matrix(XZ[,1], nrow = nrow(XZ), ncol = ncol(XZ))
    Y <- matrix(rep(y0, nrow(XZ)), nrow = nrow(XZ), ncol = ncol(XZ))
    Z <- matrix(XZ[,2], nrow = nrow(XZ), ncol = ncol(XZ))
  } else if (id == 3) {
    XZ <- expand.grid(xx, zz)
    X <- matrix(XZ[,1], nrow = nrow(XZ), ncol = ncol(XZ))
    Y <- matrix(y0 + b * (X - x0) / a, nrow = nrow(XZ), ncol = ncol(XZ))
    Z <- matrix(XZ[,2], nrow = nrow(XZ), ncol = ncol(XZ))
  } else {
    X <- NULL
    Y <- NULL
    Z <- NULL
  }

  return(list(X = X, Y = Y, Z = Z))
}

f_surf <- function(x, y) {
  2 + 0.1 * x + 0.3 * y + 0.1 * x^2 - 0.3 * x * y + 0.2 * y^2
}

xx <- seq(-3, 3, length.out = 300)
yy <- seq(-3, 3, length.out = 300)
x <- outer(xx, yy, FUN = function(a, b) a)
y <- outer(xx, yy, FUN = function(a, b) b)
z <- outer(xx, yy, FUN = f_surf)

zz <- seq(1, 5, length.out = 100)

M <- c(1, 1, 0)
v <- c(1, 1, 0)
curve_data <- get_curve(M, v, f_surf)
g <- curve_data$g
id <- curve_data$id

plane_data <- get_plane(M, v, id, xx, yy, zz)
X <- plane_data$X
Y <- plane_data$Y
Z <- plane_data$Z
```

2. Interactive plot 
```{r}
figure <- plot_ly() %>%
  add_surface(x = x, y = y, z = z, colorscale = list(list(0, "rgba(150, 150, 150, 0.1)"), list(1, "rgba(150, 150, 150, 0.1)")), showscale = FALSE, 
              contours = list(x = list(show = TRUE, color = "rgba(100,100,100, 0.8)", width = 1, usecolormap = FALSE, start = -3, end = 3, size = 0.2),
                              y = list(show = TRUE, color = "rgba(100,100,100, 0.8)", width = 1, usecolormap = FALSE, start = -3, end = 3, size = 0.2),
                              z = list(show = FALSE))) %>%
  add_surface(x = xx, y = yy, z = Z, colorscale = list(list(0, "rgb(180, 255, 180)"), list(1, "rgb(180, 255, 180)")), showscale = FALSE, opacity = 0.5, contours = list(z = list(show = FALSE))) %>%
add_trace(x = X[, 1], y = Y[, 1], z = Z[, 1], type = "scatter3d", 
          mode = "lines", line = list(color = "rgba(188, 201, 151, 0.9)", width = 2, dash = "solid"), 
          surface = list(show = TRUE, fill = "toself", color = "rgba(188, 201, 151, 0.5)", opacity = 0.1),
          showlegend = FALSE) %>%
  add_trace(x = c(2, 2), y = c(2, 2), z = c(1, 5), type = "scatter3d", mode = "lines", line = list(color = "black", width = 1), showlegend = FALSE) %>%
  add_trace(x = c(2, 2), y = c(-2, -2), z = c(1, 5), type = "scatter3d", mode = "lines", line = list(color = "black", width = 1), showlegend = FALSE) %>%
  layout(scene = list(xaxis = list(nticks = 5, range = c(2, -2), showbackground = FALSE, showgrid = FALSE, showline = TRUE, zeroline = FALSE),
                      yaxis = list(nticks = 5, range = c(2, -2),showbackground = FALSE, showgrid = FALSE,showline = TRUE, zeroline = FALSE),
                      zaxis = list(nticks = 5, range = c(1, 5), tickmode = "linear", tick0 = 1, dtick = 1, showbackground = FALSE, showgrid = 
                                     TRUE,showline = TRUE)),
         margin = list(r = 20, l = 10, b = 10, t = 10),
         font = list(family = "Times New Roman"))

figure

```


# Basic Functions for Simulations 
Let's try some basic distributions.
1) I would like to sample 100 numbers from a normal distribution with mean = 0, and standard deviation =1, and then plot a histogram.
(reference: https://aosmith.rbind.io)
```{r}
#Generating random numbers
samples <- rnorm(100, mean=0, sd=1)
hist(samples)
```

2) Using vectors of values for the parameter arguments
```{r}
rnorm(n = 100, mean = c(0, 5, 20), sd = c(1, 5, 20))
hist(samples)
  #Things are different for the n argument. If a vector is passed to n, the length of that vector is taken to be the number required (see Arguments section of documentation for details). Hereâ€™s an example. Since the vector for n is length 3, we only get 3 values.This has caught me before, as I would expect this code to give me different numbers per group instead of ignoring the information in the vector.
rnorm(n = c(1, 2, 3), mean = c(0, 5, 20), sd = c(1, 1, 1))
```

3) Uniform distribution. The uniform distribution is a continuous distribution, with numbers uniformly distributed between some minimum and maximum.
```{r}
runif(n = 5, min = 0, max = 1)
```
4) Discrete counts with rpois()-generating discrete integers (including 0) from a Poisson distribution with rpois().
The single parameter argument, lambda, is the mean. It has no default setting so must always be defined by the user.

An alternative to the Poisson distribution for discrete integers is the negative binomial distribution. Packages MASS has a function called rnegbin() for random number generation from the negative binomial distribution.
```{r}
rpois(n = 5, lambda = 2.5)
y = rpois(10000, lambda = 5)
summary(y)
hist(y) #mild right-skew when we draw a histogram of the values.
y = rpois(10000, lambda = 100) #Poisson distribution with a mean of 100. The range of values is pretty narrow; there are no values even remotely close to 0, and distribution is now pretty symmetric.
summary(y)
hist(y) 

#Generate character vectors with rep()
rep(letters[1:2], each = 3) #each 
rep(letters[1:2], times = 3) #The times argument can be used when we want to repeat the whole vector rather than repeating it element-wise.
rep(letters[1:2], times = c(2, 4))
rep(letters[1:2], each = 2, times = 3)
rep(letters[1:2], each = 2, length.out = 7)
```

# Examples
```{r}
#1. Simulate data with no differences among two groups
group  = rep(letters[1:2], each = 3)
factor = rep(LETTERS[3:5], times = 2)
response = rnorm(n = 6, mean = 0, sd = 1) 
data.frame(group, factor, response )
#2. Simultae data with a difference among groups
group_two = rep(letters[1:2], times = 3) #or length.out = 6
response_two = rnorm(n = 6, mean = c(5, 10), sd = 1)
data.frame(group_two, response_two)
#3. Multiple quantitative variables with groups
m <- data.frame(group = rep(LETTERS[3:4], each = 10), 
           x = runif(n = 20, min = 10, max = 15),
           y = runif(n = 20, min = 100, max = 150))
#4. Repeatedly simulate data with replicate() specifically made for the repeated evaluation of an expression (which will usually involve random number generation).
set.seed(16) 
replicate(n = 3, 
          expr = rnorm(n = 5, mean = 0, sd = 1), 
          simplify = FALSE )
list = list()
for (i in 1:3) {
  list[[i]] = rnorm(n = 5, mean = 0, sd = 1)
}
list
```

# A Linear Model 
https://aosmith.rbind.io/2018/01/09/simulate-simulate-part1/
```{r}
set.seed(16)
ngroup = 2
nrep = 10
b0 = 5
b1 = -2
sd = 2

(group = rep( c("group1", "group2"), each = nrep))
(eps = rnorm(n = ngroup*nrep, mean = 0, sd = sd)) 
(growth = b0 + b1*(group == "group2") + eps)
dat = data.frame(group, growth)
growthfit = lm(growth ~ group, data = dat)
summary(growthfit)

twogroup_fun = function(nrep = 10, b0 = 5, b1 = -2, sigma = 2) {
     ngroup = 2
     group = rep( c("group1", "group2"), each = nrep)
     eps = rnorm(n = ngroup*nrep, mean = 0, sd = sigma)
     growth = b0 + b1*(group == "group2") + eps
     simdat = data.frame(group, growth)
     growthfit = lm(growth ~ group, data = simdat)
     growthfit
}
set.seed(16)
twogroup_fun()
twogroup_fun(sigma = 1)
#There is one special case: if there's a single unnamed input, the second level list will be dropped. In this case, rerun(n, x) behaves like replicate(n, x, simplify = FALSE).
sims = replicate(n = 1000, twogroup_fun(), simplify = FALSE )
reruns <- purrr::rerun(1000, twogroup_fun()) 
sims[[1]]
reruns[[1]]
tidy(growthfit)
```

# Extract Simulation Results
```{r}
reruns %>%
     map_df(tidy) %>% 
     dplyr::filter(term == "groupgroup2") %>%
     ggplot2::ggplot(aes(x = estimate)) +
          geom_density(fill = "blue", alpha = .5) +
          geom_vline( xintercept = -2)
#Estimated standard deviation
#I can do a similar plot exploring estimates of the residual standard deviation. In this case I extract sigma from the model object and put it in a data.frame to plot the distribution with a density plot.
sims %>%
     map_dbl(~summary(.x)$sigma) %>%
     data.frame(sigma = .) %>%
     ggplot( aes(x = sigma) ) +
          geom_density(fill = "blue", alpha = .5) +
          geom_vline(xintercept = 2)
#The estimated variation ranges between 1 to just over 3, and the distribution is roughly centered on the true value of 2. Like with the coefficient above, the model performs pretty well on average but any single model can have a biased estimate of the standard deviation.
#The standard deviation is underestimated a bit more than 50% of the time. This is not uncommon.
#Curly braces are used to evaluate a series of expressions (separated by new lines or semicolons) and return only the last expression: f <- function() {x <- 1; y <- 2; x + y}
sims %>%
  map_dbl(~summary(.x)$sigma) %>%
  {. < 2} %>%
  mean()

sims %>%
     map_df(tidy) %>%
     dplyr::filter(term == "groupgroup2") %>%
     dplyr::pull(p.value) %>%
     {. <  0.05} %>%
     mean()
```

